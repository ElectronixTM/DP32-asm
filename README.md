# DP32-asm

**Хреновый ассемблер дла процессора DP32**

## Использование

На вход ассемблер принимает текстовые файлы а на выходе создает файлы в двух форматах - .bin и .lab. Первый - сырые байты программы, записанные в файл, второй - в формате, который можно вставить в VHDL для использования в лабораторной работе

Для испльзования необходимо запустить программу main.py. Для получения короткой справки можно передать флаг `-h`. Поскольку этот ридмишник я пишу поздно, пока ограничусь этим

Схема использования:

```bash
python3 main.py <source-file> -f <lab/bin> -o <output-file-name>
```

## Сообщения об ошибках

Пока что я не занимался выводом адекватных сведений о синтаксических ошибок, займусь этим чуть позже

## Описание синтаксиса ассемблера

В общем случае ассемблеру не важно расширение файла, но вам могут понравится `.dpasm` и `.dasm`. Сам язык ассемблера построен на основе методического пособия к лабораторной работе и содержит все команды от туда, однако записываются они немного в другой форме. Также ассемблер старается взять на себя сложности махинаций с размером операндов, поэтому инструкции, отличающиеся только размерами операндов проходят под одной и той же мнемоникой. Тем не менее порядок операндов должен строго соответсвовать порядку в методичке

Список мнемоник ассемблера таков:

- `add` - сложение r3 <- r1 + r2 или r3 <- r1 + i8
- `sub` - вычитание r3 <- r1 - r2 или r3 <- r1 - i8
- `mul` - умножение r3 <- r1 * r2 или r3 <- r1 * i8
- `div` - целочисленное деление r3 <- r1 / r2 или r3 <- r1 / i8
- `and` - побитовое И r3 <- r1 & r2
- `or` - побитовое ИЛИ r3 <- r1 | r2
- `xor` - побитовое исключающее ИЛИ r3 <- r1 ^ r2
- `mask` - побитовая маска r3 <- r1 & !r2, где `!` - инверсия
- `load` - загрузка из памяти r3 <- M[r1 + disp32] или r3 <- M[r1 + disp8]
- `store` - загрузка из памяти M[r1 + disp32] <- r3 или M[r1 + disp8] <- r3
- `branch` - команда условного перехода. Переход PC <- r1 + i8/i32 или PC <- PC + i8/i32 совершается на основе содержимого регистра флагов, который соотвествует следующй форме `условие = ((V&v)|(N&n)|(Z&z))==i`, при этом i задается произвольно. Для удобства пользования ассемблером эти условия можно задать конструкцией в фигурных скобках {i=1VNZ}. Порядок флагов важен (сложно иначе парсить регулярками), регистр - нет. Присутствие буквы переведется в 1, отсутствие в 0

Для упрощения навигации по памяти вводятся метки. Фактически на этапе ассемблирования все метки превратятся в числа. На данный момент в реализации ассемблера метка считается 32битным числом не зависимо от того, какое фактически число в ней лежит. Будьте внимательны с этим, так как это может создавать не оптимизированный или нежелательный код. Метка вводится как `label1:`, а затем к ней можно обращаться просто по имени, как `label1`

Пример программы:

```
loop:
add r3 r1 r2
sub r3 r3 r2
sub r3 r3 r1
branch {i=1z} loop
```

