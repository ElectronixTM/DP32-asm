# DP32-asm

**Простой ассемблер для процессора DP32**

## Установка

Проект можно установить несколькими способами.

### Установка через git

Склонируйте себе данный репозиторий и выполните в корневой дирректории следующую команду.

```bash
pip install .
```

### Установка через wheel

В релизах в прикрепленных файлах прикладываются скомпилированные варианты данной программы. Скачайте файл `dp32_asm-0.3.1-py3-none-any.whl` и установите его командой.

```
pip intall dp32_asm-0.3.1-py3-none-any.whl
```

## Использование

После установки, ассемблер можно вызвать командой dp32asm.

На вход ассемблер принимает текстовые файлы а на выходе создает файлы в двух форматах - .bin и .lab. Первый - сырые байты программы, записанные в файл, второй - в формате, который можно вставить в VHDL для использования в лабораторной работе.

Схема использования:

```bash
dp32asm <source-file> -f <lab/bin> -o <output-file-name>
```

## Генерация отладочной информации

В ассемблер встроена возможность генерации отладочной информации. Она добавлена для дебаггера, который вы сможете найти на https://git.inkling.su/ElectronixTM/dp32-proto.git. Он сырой и нужен был по долгу службы. Опирается на программную эмуляцию процессора DP32, поэтому не дает гарантий, что отдебаженный на ней код будет работать на реальном VHDL проекте. 

Чтобы сгенерировать отладочный файл (по умолчанию dbg.json), достаточно передать флаг -d. Если хочется заодно указать, в какой файл отладочную информацию сложить - можно передать параметр --debug-file:

```
dp32asm <source-file> -o <output-file-name> -d --debug-file <debug-file-name>
```

Отладочный файл представляет собой обычный json файл со следующей структурой:

```json
{
    "src": "absolute/path/to/source"
    "labels" : {
        "label1": 1
        "label2": 2
        ...
    },
    "instructions" : {
        "<offset-in-words>" : {
        "lenght": 2,
        "srcline": 3
        }
        ...
    }
}
```

## Описание синтаксиса ассемблера

В общем случае ассемблеру не важно расширение файла, но вам могут понравится `.dpasm` и `.dasm`. Сам язык ассемблера построен на основе методического пособия к лабораторной работе и содержит все команды от туда, однако записываются они немного в другой форме. Также ассемблер старается взять на себя сложности махинаций с размером операндов, поэтому инструкции, отличающиеся только размерами операндов проходят под одной и той же мнемоникой. Тем не менее порядок операндов должен строго соответсвовать порядку в методичке.

Список мнемоник ассемблера таков:

- `add` - сложение r3 <- r1 + r2 или r3 <- r1 + i8.
- `sub` - вычитание r3 <- r1 - r2 или r3 <- r1 - i8.
- `mul` - умножение r3 <- r1 * r2 или r3 <- r1 * i8.
- `div` - целочисленное деление r3 <- r1 / r2 или r3 <- r1 / i8.
- `and` - побитовое И r3 <- r1 & r2.
- `or` - побитовое ИЛИ r3 <- r1 | r2.
- `xor` - побитовое исключающее ИЛИ r3 <- r1 ^ r2.
- `mask` - побитовая маска r3 <- r1 & !r2, где `!` - инверсия.
- `load` - загрузка из памяти r3 <- M[r1 + disp32] или r3 <- M[r1 + disp8].
- `store` - загрузка из памяти M[r1 + disp32] <- r3 или M[r1 + disp8] <- r3.
- `branch` - команда условного перехода. Переход PC <- r1 + i8/i32 или PC <- PC + i8/i32 совершается на основе содержимого регистра флагов, который соотвествует следующй форме `условие = ((V&v)|(N&n)|(Z&z))==i`, при этом i задается произвольно. Для удобства пользования ассемблером эти условия можно задать конструкцией в фигурных скобках {i=1VNZ}. Порядок флагов важен (сложно иначе парсить регулярками), регистр - нет. Присутствие буквы переведется в 1, отсутствие в 0.
- `db`, `dh`, `dw` - диррективы резервирования памяти - 8 бит, 16 бит и 32 бита соотвественно. Все они не являются командами процессору и просто заполняют кусок памяти указанными числами. Все эти команды держат выравнивание и *заполняют строку слева направо*, все, что требуется довыровнять забивается нулями. Положить сюда вы можете все, что ассемблер распознает как число, а именно: числовые литераллы, все, что через `#define` переводится в число, имена меток (он вобьет указатель на них), относительные метки (Стоит учитывать, что их расположение считается относительно их конца. То есть положенное число может на единицу отличаться от того, что вы ожидаете), даже условия `{i=2vz}`, поскольку это синтаксический сахар, заменяющий собой числа.

Для упрощения навигации по памяти вводятся метки. Фактически на этапе ассемблирования все метки превратятся в числа. На данный момент в реализации ассемблера метка считается 32битным числом не зависимо от того, какое фактически число в ней лежит. Будьте внимательны с этим, так как это может создавать не оптимизированный или нежелательный код. Метка вводится как `label1:`, а затем к ней можно обращаться просто по имени, как `label1`.

Пример программы:

```
loop:
add r3 r1 r2
sub r3 r3 r2
sub r3 r3 r1
branch {i=1z} rel loop
```

Ключевое слово `rel` указывает на то, что в этом конкретном месте нужно вставить не абсолютный адрес метки, а смещение до нее (оно может быть как положительное, так и отрицательное). Даже если смещение мало, оно все еще считается 32 битным числом - не забывайте об этом.

Следует заметить, что `rel` будет встречаться почти в каждой операции ветвления, так как, согласно его спецификации, число, стоящее после условия перехода, будет _прибавлено_ к значению счетчика команд pc. Это обязаывает программиста писать `rel` после каждой команды, чтобы адрес до метки считался корректно. Однако есть и другие способы. Например можно использовать `branch {i=0} [r100 + label]` также перекинет вас на нужную метку со смещением, которое содержится в r100. В примерах указывается, что этот регистр кроме нуля ничего содержать не будет, но это лишь условность для удобства написания.

## Типы операндов

1. Регистры - находятся в диапазоне `r0` - `r255`.
2. Числа - то, что вы пишете напрямую: -6, 12. При этом метки тоже считаются числами, только они априорно 32 битные независимо от их фактического содержимого.
3. Условия - синтаксический сахар, позволяющий читаемо записать условия в необходимом для процессора виде. Пример может выглядеть так: `{i=1VZ}` - проверяет, стоит ли флаг oVerflow или Zero в единице.
4. Память - только в ней можно задействовать возможности процессора по адресации. Используются в основном для команд работы с памятью и необходимы в условном ветвлении с применением регистров. Пишутся в квадратных скобках: `[r27 + 1024]`. Также можно использовать имена меток, если команда позволяет 32 битные числа: `[r21 + x]`. Плюс здесь не обязателен и ставится только для красоты, а вот порядок операндов важен, сначала идет регистр, потом число. Внутри скобок также работает `rel`: `[r22 + rel main]`.

## 2 команды препроцессору

В ассемблере на данный момент есть всего 2 команды препроцессору - `#define` и `#undefine`. Нужны они чтобы заводить поименованные константы.

```
#define x 12

arg: db x 13 x 13

#undefine x
```

В отличие от подобной команды препроцессору языка C, эта зменит только то, что может быть именем метки, а остальное проигнорирует.

Функциональность этих 2 команд я почти не тестировал, поэтому буду рад, если поделитесь замечаниями, которые возникнут в процессе вашей работы.

## Примеры

В папке examples вы сможете найти примеры кода на языке этого ассемблера, что может помочь вам немного лучше понять его синтаксис. Эти примеры точно не являются оптимальными. Не стоит воспринимать их стиль как единственно верный подход к написанию программ.

## Пояснение к ошибкам

Поддержка ошибок сделана не очень приятно для пользователя, потому что ассемблер не считает своим долгом выдавать диагностику неисправности. В основном он просто укажет на то место, с которого у него что-то пошло не так. В связи с этим для упрощения отладки (которая видимо больше умозрительная) я поясню по поводу некоторых сообщений.

### Ошибки лексера

Он подчеркнет символы, на которых что-то пошло не так. Лексер не будет смотреть на дифайны, они нужны только для того, чтобы заменить то, что может быть именами меток, то есть для создания поименованных констант.

### Ошибки парсера

Поскольку парсер не знает, где он находится в контексте исходного кода и кушает только выход лексера (токены), он только укажет вам строку с символом, на котором возникла ошибка и выдаст его тип.

### Ошибки ассемблирования

Бывают разные, но могут разбиться об использование разных вещей вроде несуществующих меток или использование направильных размеров операндов. Последнее поясню:

Когда вы пытаетесь положить в 8 битное поле число, которое туда поместиться не может (а могут только -128 -> 127), вам не скажет, что произошло переполнение, вам скажет, что типы операндов не сходятся. Дело в том, что ассемблер изо всех сил старается сделать то, что вы ему написали и если вы пытаетесь в 8 битное поле затолкать 277, то он попытается как-то привести это число к какому-то типу и ему останется только решить, что это 32-битное поле. Но для арифметики например 32-битное поле не задействуется нигде, поэтому он упадет именно по типам операндов, а не по переполнениям.
